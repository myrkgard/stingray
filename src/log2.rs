//! The log2 module.

use num_bigint::BigUint;

/// Provides $`log_2(n)`$.
pub trait Log2 {
    /// Returns the base 2 logarithm of the number.
    fn log2(&self) -> f64;
}

impl Log2 for BigUint {
    /// The maximum value of [`f64`] is about $`1{,}8 \cdot 10^{308}`$.
    /// Using:
    /// ```math
    /// \begin{align}
    /// log_2(ab) &= log_2(a) + log_2(b) \\
    /// log_2(a^{bc}) &= log_2(a^b) \cdot c
    /// \end{align}
    /// ```
    /// We approximate $`n`$ as $`m`$: 
    /// ```math
    /// \begin{align}
    /// n &\approx m = p \cdot 10^{k \cdot 300} \\
    /// log_2(n) &\approx log_2(m) = log_2(p \cdot 10^{k \cdot 300}) = log_2(p) + log_2(10^{300}) \cdot k
    /// \end{align}
    /// ```
    /// Where $`log_2(10^{300})`$ is known at compile-time, thanks to [`wolframalpha`]
    /// and all values used are now small enough to fit into [`f64`].
    ///
    /// [`f64`]: https://doc.rust-lang.org/std/primitive.f64.html
    /// [`wolframalpha`]: https://wolframalpha.com
    fn log2(&self) -> f64 {
        const X: usize = 300;
        const Y: f64 = 996.5784284662; // log2(10^300)

        let s = self.to_str_radix(10);
        let len = s.len();

        let sa = &s[0..(len % X)];
        let a = sa.parse::<f64>().unwrap().log2();
        let b = Y * ((len / X) as f64);

        a + b
    }
}

#[cfg(test)]
mod tests {

    #[test]
    fn validate_log2_0() {
        use super::*;
        use num_traits::Num;

        let m = String::from("0");
        let p = BigUint::from_str_radix(&m, 10).unwrap();
        let approx = p.log2(); // log2(0) = -âˆž
        assert_eq!(approx, f64::NEG_INFINITY);
    }

    #[test]
    fn validate_log2_1() {
        use super::*;
        use num_traits::Num;

        let m = String::from("1");
        let p = BigUint::from_str_radix(&m, 10).unwrap();
        let approx = p.log2();
        assert_eq!(approx, 0.);
    }

    #[test]
    fn validate_log2_23() {
        use super::*;
        use num_traits::Num;

        let m = String::from("23");
        let p = BigUint::from_str_radix(&m, 10).unwrap();
        let digits = m.len();
        let exact = 4.5235f64;
        let approx = p.log2();
        let err = (approx - exact).abs();
        let max_err = 1.0f64;
        println!(
            "digits={}, exact={}, approx={}, err={}",
            digits, exact, approx, err
        );
        assert!(err <= max_err);
    }

    #[test]
    fn validate_log2_300() {
        use super::*;
        use num_traits::Num;

        let m = String::from("106801263082344606444986643094632426733701465983471787357119291373803021810914197506211423547401768336222345945311255641097054865954920119282449991912388366890585807029162882923841296474031428927308551603322604968095145339703349808865052420462342385101520519803457509609701975862077916847708265587561714346159");
        let p = BigUint::from_str_radix(&m, 10).unwrap();
        let digits = m.len();
        let exact = 1023.2487f64;
        let approx = p.log2();
        let err = (approx - exact).abs();
        let max_err = 1.0f64;
        println!(
            "digits={}, exact={}, approx={}, err={}",
            digits, exact, approx, err
        );
        assert!(err <= max_err);
    }

    #[test]
    fn validate_log2_600() {
        use super::*;
        use num_traits::Num;

        let m = String::from("10680126308234460644999999999900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
        let p = BigUint::from_str_radix(&m, 10).unwrap();
        let digits = m.len();
        let exact = 2056.3684f64;
        let approx = p.log2();
        let err = (approx - exact).abs();
        let max_err = 1.0f64;
        println!(
            "digits={}, exact={}, approx={}, err={}",
            digits, exact, approx, err
        );
        assert!(err <= max_err);
    }

    #[test]
    fn validate_log2_900() {
        use super::*;
        use num_traits::Num;

        let m = String::from("10680126308234460644999999999900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
        let p = BigUint::from_str_radix(&m, 10).unwrap();
        let digits = m.len();
        let exact = 3052.9468f64;
        let approx = p.log2();
        let err = (approx - exact).abs();
        let max_err = 1.0f64;
        println!(
            "digits={}, exact={}, approx={}, err={}",
            digits, exact, approx, err
        );
        assert!(err <= max_err);
    }

    #[test]
    fn validate_log2_1200() {
        use super::*;
        use num_traits::Num;

        let m = String::from("10680126308234460644999999999900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
        let p = BigUint::from_str_radix(&m, 10).unwrap();
        let digits = m.len();
        let exact = 4049.5252f64;
        let approx = p.log2();
        let err = (approx - exact).abs();
        let max_err = 1.0f64;
        println!(
            "digits={}, exact={}, approx={}, err={}",
            digits, exact, approx, err
        );
        assert!(err <= max_err);
    }

    #[test]
    fn validate_log2_1500() {
        use super::*;
        use num_traits::Num;

        let m = String::from("10680126308234460644999999999900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
        let p = BigUint::from_str_radix(&m, 10).unwrap();
        let digits = m.len();
        let exact = 5046.1037f64;
        let approx = p.log2();
        let err = (approx - exact).abs();
        let max_err = 1.0f64;
        println!(
            "digits={}, exact={}, approx={}, err={}",
            digits, exact, approx, err
        );
        assert!(err <= max_err);
    }
}
